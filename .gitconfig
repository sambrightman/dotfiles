[alias]
	a = add
	ac = !git a . && git cm
	ai = add --interactive
	ama = am --abort
	amc = am --continue
	amscp = am --show-current-patch
	ams = am --skip
	ap = add --patch
	at = !"append_ticket() { if [ $# -gt 0 ]; then git ca -m \"$1 $(git lgs)\n\n$(git lgb)\"; else echo 'supply some ticket(s) to prepend to the summary'; fi; }; append_ticket"
    authors = shortlog -s -e -n --all
	br = branch -vv
	brav = branch --all -vv
	bss = bisect start
	bsb = bisect bad
	bsg = bisect good
	bsl = bisect log
	bsr = bisect run
	brc = !"git for-each-ref --format='%(committerdate) %09 %(authorname) %09 %(refname)' | sort -k5n -k2M -k3n -k4n"
	ca = commit --amend
	caa = !"amend_author() { local author=\"$1\" && shift; git ca --no-edit --author \"$author\" \"$@\" && git rc; }; amend_author"
	ce = config --global --edit
	co = checkout
	cob = checkout -b
	cocs = !"checkout_clean_submodules() { git co $1; git smu; git cfd; git smc; }; checkout_clean_submodules"
	cfd = clean -ffd
	ci = commit
	cm = commit -m
	cia = commit -C HEAD@{1}
	ciae = commit -c HEAD@{1}
	cp = cherry-pick
	cpa = cherry-pick --abort
	cpc = cherry-pick --continue
	dc = diff --cached
	ds = diff --stat
	du = !git diff --pretty=authoneline --reverse $(git ub)..
	ffm = merge --ff-only
	fu = commit --amend --no-edit
	fuc = commit --fixup
	lg = log --pretty=authoneline
	lga = log -n1 HEAD@{1}
	lgf = log --pretty=authonelinefull
	lgs = !"log_summary() { git log -n1 --format=%s HEAD~${1:-0}; }; log_summary"
	lgb = !"log_body() { git log -n1 --format=%b HEAD~${1:-0}; }; log_body"
	lgi = !git log --pretty=authoneline ..$(git ub)
	lgu = !git log --pretty=authoneline --reverse $(git ub)..
	lgus = !git lgu --stat
	lgut = !git lgu | tail
	lsall = !"list_all() { git log --all --pretty=format: --name-only --diff-filter=A \"$@\" | grep . | sort -u; }; list_all"
	ma = merge --abort
	me = !"git lg --author=\"$(git config user.name)\""
	pp = !"git lgu; echo; git du --stat"
	pr = pull --rebase
	prp = !git pr && git push
	pf = push --force-with-lease
	ra = rebase --abort
	rb = rebase
	rc = rebase --continue
	rs = rebase --skip
	ri = rebase --interactive
	rl = reflog --pretty=refonelinefull
	rsh = reset HEAD
	rsa = reset --hard
	rsp = reset --patch
	rss = reset --soft
	rssh = reset --soft HEAD~1
	release = !"release_name() { git describe --tags --match \"$(basename $(pwd))-v*\" --exclude '*-rc*'; }; release_name"
	customrelease = !"custom_release() { \
                          if [ $# -lt 1 ]; then \
                              echo \"usage: git drw_release version\"; \
                              return; \
                          fi; \
                          local version=$1 && shift; \
                          local repo_name=$(git reponame); \
                          local release_pattern; \
                          if [ \"${repo_name}\" = '' ]; then \
                              release_pattern=\"${version}\"; \
                          else \
                              release_pattern=\"${version}\"; \
                          fi; \
                          git describe --tags --match \"${release_pattern}\" --abbrev=0; \
                      }; custom_release"
	renametag = !"renametag() { local oldtag=$1 && shift; local newtag=$1 && shift; if [[ -z \"$oldtag\" || -z \"$newtag\" ]]; then echo \"usage: git renametag oldtag newtag\"; return 1; fi; git tag $newtag $(git cat-file -p $oldtag | sed \"s/^tag $oldtag$/tag $newtag/\" | git mktag) && git tag -d $oldtag; }; renametag"
	raf = !"add_fork() { local remote=$1 && shift; local org=${1:-${remote}} && shift; local original_remote=${1:-origin} && shift; if [[ -z \"${remote}\" || -z \"${org}\" ]]; then echo \"usage: git raf remote org [original_remote]\"; git remotes; return 1; else local remote_url=$(git url ${remote}); if [[ -n \"${remote_url}\" ]]; then echo \"${remote} already exists with URL ${remote_url}\"; else local fork_url=$(git forkurl ${org} ${original_remote}); echo \"adding ${remote} -> ${fork_url}\"; git remote add ${remote} ${fork_url}; fi; fi; }; add_fork"
	remotes = !"show_remotes() { local remote; for remote in $(git remote show); do printf \"%-20s %s\n\" ${remote} $(git url ${remote}); done; }; show_remotes"
	rso = remote show origin
	rv = revert --no-commit
	rva = revert --abort
	rvc = revert --continue
	rvh = revert --no-commit HEAD
	sa = stash apply
	sd = stash drop
	sl = stash list --pretty=stashoneline
	sm = submodule
	smc = submodule foreach --recursive git clean -ffd
	sms = submodule foreach --recursive git status
	smu = submodule update --init --recursive
	sp = stash pop
	sr = !"renamestash() { local number=$1 && shift; local message=$1 && shift; if [[ -z \"${number}\" || -z \"${message}\" ]]; then echo \"usage: git sr number name\"; git stash list; return 1; else local stash=\"stash@{$number}\"; local rev=$(git rev-parse \"${stash}\"); git stash drop \"${stash}\" || return 1; git stash store -m \"${message}\" \"${rev}\" || return 1; git stash list; fi }; renamestash"
	ss = stash show --patch
	su = stash push --keep-index --include-untracked
	st = status
	sti = status --ignore
	bb = !echo $(git cb)_bb
	cb = rev-parse --abbrev-ref HEAD
	ub = rev-parse --abbrev-ref --symbolic-full-name @{u}
	qb = !git br $(git bb)
	qd = !git br -D $(git bb)
	db = !git diff $(git bb)
	forkurl = !"fork_url() { local fork=$1 && shift; local remote=${1:-origin}; git url ${remote} | sed -Ee \"s/:[^/]+/:$fork/\"; }; fork_url"
	url = !"remote_url() { git config remote.${1:-origin}.url; }; remote_url"
	reponame = !"repo_name() { \
                     local url; \
                     for remote in upstream origin; do \
                         url=$(git url ${1:-${remote}}); \
                         [ -n \"${url}\" ] && break; \
                     done; \
                     local repo_path=\"${url##*:}\"; \
                     local repo_name=\"$(basename $(dirname ${repo_path}))/$(basename ${repo_path} .git)\"; \
                     echo ${repo_name}; \
                 }; repo_name"
	name = show --name-only
	graph = log --graph --all --pretty=graphtight --abbrev-commit --date=relative
	biggraph = log --graph --all --pretty=graphloose --abbrev-commit
	tags = tag
	tagdates = log --tags --simplify-by-decoration --pretty=tagdates
	conflicts = diff --name-only --diff-filter=U
	contains = branch -a --contains
	ignored = ls-files --others --exclude-standard --ignored
	untracked = ls-files --others --exclude-standard
	alias = !"some_filter() { if [ $# -gt 0 ]; then grep $*; else cat; fi; }; git config --list | grep alias | some_filter"
	smcf = !"submodule_commit_for() { \
                 if [ $# -lt 2 ]; then \
                     echo \"usage: git smcf submodule_path superproject_commit\"; \
                     return; \
                 fi; \
                 local submodule_path=$1 && shift; \
                 local commit=$1 && shift; \
                 local prefix="."; \
                 local suffix=\"${submodule_path%%/}/\"; \
                 local work_dir=$(git rev-parse --show-superproject-working-tree); \
                 local new_submodule=${prefix}; \
                 while [ -n \"${suffix}\" ]; do \
                     if [ -n \"${new_submodule}\" ]; then \
                         commit=$(git -C ${prefix} ls-tree --full-tree ${commit} ${suffix} | awk '{ print $3 }'); \
                         new_submodule=; \
                     fi; \
                     prefix=\"${prefix}/${suffix%%/*}\"; \
                     suffix=\"${suffix#*/}\"; \
                     local new_work_dir=$(git -C ${prefix} rev-parse --show-superproject-working-tree); \
                     if [ \"${new_work_dir}\" != \"${work_dir}\" ]; then \
                         work_dir=${new_work_dir}; \
                         local new_submodule=${prefix}; \
                     fi; \
                 done; \
                 echo ${commit}; \
             }; submodule_commit_for"
	smrc = !"submodule_release_commit() { \
                 if [ $# -lt 2 ]; then \
                     echo \"usage: git smrc submodule_path release\"; \
                     return; \
                 fi; \
                 local submodule_path=$1 && shift; \
                 local release=$1 && shift; \
                 git smcf ${submodule_path} $(git customrelease ${release}); \
             }; submodule_release_commit"
	smrl = !"submodule_release_log() { \
                 if [ $# -lt 2 ]; then \
                     echo \"usage: git smrl submodule_path release\"; \
                     return; \
                 fi; \
                 local submodule_path=$1 && shift; \
                 local release=$1 && shift; \
                 git -C ${submodule_path} lgf $(git smrc ${submodule_path} ${release}); \
             }; submodule_release_log"
	findsmc = !"find_submodule_commit() { \
                    if [ $# -lt 2 ]; then \
                         echo \"usage: git findsmc submodule_path commit\"; \
                         return; \
                    fi; \
                    local submodule_path=\"./$1\" && shift; \
                    local commit=$1 && shift; \
                    local path=\"${submodule_path}\"; \
                    local work_dir=$(git -C ${path} rev-parse --show-superproject-working-tree); \
                    while [ \"${path}\" != \"${prev_path}\" ]; do \
                        local prev_path=${path}; \
                        path=\"${path%/*}\"; \
                        local prev_work_dir=${work_dir}; \
                        local work_dir=$(git -C ${path} rev-parse --show-superproject-working-tree); \
                        if [ \"${prev_work_dir}\" != \"${work_dir}\" -o \"${prev_path}\" = \".\" ]; then \
                            local sub_path=${submodule_path#${prev_path}}; \
                            submodule_path=${submodule_path%${sub_path}}; \
                            sub_path=${sub_path#/}; \
                            if [ -n \"${sub_path}\" ]; then \
                                echo searching for ${prev_path} commit that has ${commit} in ${sub_path}:; \
                                echo; \
                                local initial_commit=$(git -C ${prev_path} rev-list --reverse HEAD -- ${sub_path} | head -1); \
                                git -C ${prev_path} bisect start --no-checkout --term-bad=containing HEAD ${initial_commit} -- ${sub_path}; \
                                git -C ${prev_path} bisect run sh -c \"git -C ${sub_path} merge-base --is-ancestor ${commit} \\$(git rev-parse BISECT_HEAD:${sub_path}); exit_code=\\$?; if [ \\${exit_code} -lt 2 ]; then exit \\$((1 - \\${exit_code})); else exit \\${exit_code}; fi\" || exit 1; \
                                commit=$(git -C ${prev_path} rev-parse bisect/containing); \
                                echo; \
                                echo found ${commit}, contained in tags:; \
                                echo; \
                                git -C ${prev_path} tag --contains $(git -C ${prev_path} bisect view --format='%H'); \
                                git -C ${prev_path} bisect reset; \
                            fi; \
                        fi; \
                    done; \
                }; find_submodule_commit"
[pretty]
	graphtight = %C(bold red)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)- %an%C(reset)%C(bold yellow)%d%C(reset)
	graphloose = %C(bold red)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n          %C(white)%s%C(reset) %C(bold white)- %an%C(reset)
	authoneline = %C(bold red)%h %C(reset)%s %C(bold green)%aN %C(bold magenta)(%ar)%C(reset)%C(yellow)%d%C(reset)
	authonelinefull = %C(bold red)%h %C(reset)%s %C(bold green)%aN %C(bold magenta)(%aD)%C(reset)%C(yellow)%d%C(reset)
	stashoneline = %C(bold red)%h %C(bold green)%gd %C(reset)%gs %C(bold green)%aN %C(bold magenta)(%ar)%C(reset)%C(yellow)%d%C(reset)
	refonelinefull = %C(auto)%h %gd: %gs %C(bold magenta)(%aD)%C(reset)
	tagdates = %ci %d
[format]
	pretty = fuller
[user]
	name = Sam Brightman
	# email from include
[include]
	path = .gitconfig_user
	path = .gitconfig_tokens
	path = .gitconfig_bullshit
[branch]
	autosetupmerge = always
	autosetuprebase = always
[color]
	ui = true
[core]
	editor = emacswrapper
	excludesFile = ~/.gitignore
[diff]
	noprefix = true
[pager]
	blame = less -S
[pull]
	rebase = true
[push]
	default = current
	followTags = true
[rebase]
	autosquash = true
	autostash = true
[github]
	user = sambrightman
[filter "lfs"]
	clean = git-lfs clean -- %f
	smudge = git-lfs smudge -- %f
	required = true
	process = git-lfs filter-process
[credential]
	helper = store
